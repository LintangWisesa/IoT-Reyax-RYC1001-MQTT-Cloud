/**
 * Generated by Eclipse Mita 0.1.0.
 * @date 2021-06-29 11:06:59
 */


#include <BCDS_ServalPal.h>
#include <BCDS_ServalPalWiFi.h>
#include <stdint.h>
#include <inttypes.h>
#include <Serval_StringDescr.h>
#include <XDK_TimeStamp.h>
#include <time.h>
#include <HTTPRestClientSecurity.h>
#include <MbedTLSAdapter.h>
#include <XDK_SNTP.h>
#include <BCDS_BSP_Board.h>
#include <BCDS_WlanNetworkConfig.h>
#include <XdkCommonInfo.h>
#include <Serval_Mqtt.h>
#include <BCDS_Retcode.h>
#include "MitaExceptions.h"

/**
 * The client identifier (here: clientID) is a identifier of each MQTT client
 * connecting to a MQTT broker. It needs to be unique for the broker to
 * know the state of the client.
 *
 * We define this client ID globally to ensure it's available in memory even
 * after it was passed to the Serval stack in the setup method.
 */
static const char* MQTT_CLIENT_ID = "user+4digitrandom";

static const char* MQTT_BROKER_HOST = "iot.reyax.com";

static const uint16_t MQTT_BROKER_PORT = 1883;

/**<  Macro for the non secure serval stack expected MQTT URL format */
#define MQTT_URL_FORMAT          "mqtt://%s:%d"

/**< Handle for MQTT subscribe operation  */
static SemaphoreHandle_t mqttSubscribeHandle;
/**< Handle for MQTT publish operation  */
static SemaphoreHandle_t mqttPublishHandle;
/**< Handle for MQTT send operation  */
static SemaphoreHandle_t mqttSendHandle;
/**< Handle for MQTT send operation  */
static SemaphoreHandle_t mqttConnectHandle;
/**< MQTT session instance */
static MqttSession_T mqttSession;
/**< MQTT connection status */
static bool mqttIsConnected = false;
/**< MQTT subscription status */
static bool mqttIsSubscribed = false;
/**< MQTT publish status */
static bool mqttWasPublished = false;

#define TASK_PRIORITY_SERVALPAL_CMD_PROC            UINT32_C(3)
#define TASK_STACK_SIZE_SERVALPAL_CMD_PROC          UINT32_C(600)
#define TASK_QUEUE_LEN_SERVALPAL_CMD_PROC           UINT32_C(10)
StringDescr_T username;
const char* usernameBuf = "username";

StringDescr_T password;
const char* passwordBuf = "password";

static retcode_t MqttEventHandler(MqttSession_T* session, MqttEvent_t event, const MqttEventData_t* eventData);
static Retcode_T connectToBackend(void);

Retcode_T ConnectivityMQTTBroker_Setup(void)
{
	Retcode_T exception = RETCODE_OK;
	StringDescr_wrap(&username, usernameBuf);
	StringDescr_wrap(&password, passwordBuf);
	
	
	/**< Handle for Serval PAL thread command processor */
	static CmdProcessor_T ServalPALCmdProcessorHandle;
	
	exception = CmdProcessor_Initialize(&ServalPALCmdProcessorHandle, "Serval PAL", TASK_PRIORITY_SERVALPAL_CMD_PROC, TASK_STACK_SIZE_SERVALPAL_CMD_PROC, TASK_QUEUE_LEN_SERVALPAL_CMD_PROC);
	
	if (RETCODE_OK == exception)
	{
		exception = ServalPal_Initialize(&ServalPALCmdProcessorHandle);
	}
	if (RETCODE_OK == exception)
	{
		exception = ServalPalWiFi_Init();
	}
	
	
	
	mqttSubscribeHandle = xSemaphoreCreateBinary();
	if (NULL == mqttSubscribeHandle)
	{
		exception = RETCODE(RETCODE_SEVERITY_ERROR, RETCODE_OUT_OF_RESOURCES);
	}
	
	if(exception != NO_EXCEPTION) return exception;
	
	mqttPublishHandle = xSemaphoreCreateBinary();
	if (NULL == mqttPublishHandle)
	{
		vSemaphoreDelete(mqttSubscribeHandle);
		exception = RETCODE(RETCODE_SEVERITY_ERROR, RETCODE_OUT_OF_RESOURCES);
	}
	
	if(exception != NO_EXCEPTION) return exception;
	
	mqttSendHandle = xSemaphoreCreateBinary();
	if (NULL == mqttSendHandle)
	{
		vSemaphoreDelete(mqttSubscribeHandle);
		vSemaphoreDelete(mqttPublishHandle);
		exception = RETCODE(RETCODE_SEVERITY_ERROR, RETCODE_OUT_OF_RESOURCES);
	}
	
	if(exception != NO_EXCEPTION) return exception;
	
	mqttConnectHandle = xSemaphoreCreateBinary();
	if (NULL == mqttConnectHandle)
	{
		vSemaphoreDelete(mqttSubscribeHandle);
		vSemaphoreDelete(mqttPublishHandle);
		vSemaphoreDelete(mqttSendHandle);
		exception = RETCODE(RETCODE_SEVERITY_ERROR, RETCODE_OUT_OF_RESOURCES);
	}
	
	return exception;
	
	return NO_EXCEPTION;
}

Retcode_T ConnectivityMQTTBroker_Enable(void)
{
	Retcode_T exception = RETCODE_OK;
	
	Ip_Address_T brokerIpAddress = 0UL;
	StringDescr_T clientID;
	char mqttBrokerURL[30] = { 0 };
	char serverIpStringBuffer[16] = { 0 };
	
	
	if(RETCODE_OK == exception)
	{
		exception = ServalPalWiFi_NotifyWiFiEvent(SERVALPALWIFI_CONNECTED, NULL);
	}
	
	if(RETCODE_OK != exception)
	{
		return exception;
	}
	
	
	
	retcode_t mqttRetcode = RC_OK;
	mqttRetcode = Mqtt_initialize();
	if (RC_OK != mqttRetcode)
	{
		printf("[ERROR, %s:%d] MQTT_Enable : MQTT init failed: %x\n", __FILE__, __LINE__, mqttRetcode);
		exception = RETCODE(RETCODE_SEVERITY_ERROR, RETCODE_MQTT_INIT_FAILED);
	}
	
	if(exception != NO_EXCEPTION) return exception;
	
	mqttRetcode = Mqtt_initializeInternalSession(&mqttSession);
	if (RC_OK != mqttRetcode)
	{
		printf("[ERROR, %s:%d] MQTT_Enable : MQTT init session failed: %x\n", __FILE__, __LINE__, mqttRetcode);
		exception = RETCODE(RETCODE_SEVERITY_ERROR, RETCODE_MQTT_INIT_INTERNAL_SESSION_FAILED);
	}
	
	if(exception != NO_EXCEPTION) return exception;
	
	exception = WlanNetworkConfig_GetIpAddress((uint8_t *) MQTT_BROKER_HOST, &brokerIpAddress);
	if(RETCODE_OK != exception) {
		printf("[ERROR, %s:%d] MQTT_Enable : Failed to resolve host: %s\n", __FILE__, __LINE__, MQTT_BROKER_HOST);
		return exception;
	}
	
	if(exception != NO_EXCEPTION) return exception;
	
	if (0 > Ip_convertAddrToString(&brokerIpAddress, serverIpStringBuffer))
	{
		printf("[ERROR, %s:%d] MQTT_Enable : Failed to convert IP\n", __FILE__, __LINE__);
		exception = RETCODE(RETCODE_SEVERITY_ERROR, RETCODE_MQTT_IPCONIG_FAIL);
	}
	
	if(exception != NO_EXCEPTION) return exception;
	
	mqttSession.MQTTVersion = 4;
	mqttSession.keepAliveInterval = 60;
	mqttSession.cleanSession = false;
	mqttSession.will.haveWill = false;
	mqttSession.onMqttEvent = MqttEventHandler;
	mqttSession.username = username;
	mqttSession.password = password;
	
	StringDescr_wrap(&clientID, MQTT_CLIENT_ID);
	mqttSession.clientID = clientID;
	
	size_t neccessaryBytes = snprintf(mqttBrokerURL, sizeof(mqttBrokerURL), MQTT_URL_FORMAT, serverIpStringBuffer, MQTT_BROKER_PORT);
	if(neccessaryBytes > sizeof(mqttBrokerURL)) {
		printf("[ERROR, %s:%d] MQTT_Enable : Failed to convert IP\n", __FILE__, __LINE__);
		exception = RETCODE(RETCODE_SEVERITY_ERROR, RETCODE_OUT_OF_RESOURCES);
	}
	
	if(exception != NO_EXCEPTION) return exception;
	
	mqttSession.target.scheme = SERVAL_SCHEME_MQTT;
	if (RC_OK == SupportedUrl_fromString((const char *) mqttBrokerURL, (uint16_t) strlen((const char *) mqttBrokerURL), &mqttSession.target))
	{
		exception = connectToBackend();
	}
	else
	{
		printf("[ERROR, %s:%d] MQTT_Enable : Failed to parse IP/port: %s\n", __FILE__, __LINE__, mqttBrokerURL);
		exception = RETCODE(RETCODE_SEVERITY_ERROR, RETCODE_MQTT_PARSING_ERROR);
	}
	
	return exception;
	
	return NO_EXCEPTION;
}

/**
 * Provides read access to the topik signal.
 */
Retcode_T ConnectivityMQTTBroker_Topik_Read(char** result)
{
	
	return NO_EXCEPTION;
}

/**
 * Provides write access to the topik signal.
 */
Retcode_T ConnectivityMQTTBroker_Topik_Write(char** value)
{
	Retcode_T exception = RETCODE_OK;
	
	if(!mqttIsConnected) {
		printf("[INFO, %s:%d] MQTT_Write : Reconnecting...\n", __FILE__, __LINE__);
		exception = connectToBackend();
		if(mqttIsConnected) {
			printf("[INFO, %s:%d] MQTT_Write : Connected.\n", __FILE__, __LINE__);
		}
		else {
			printf("[ERROR, %s:%d] MQTT_Write : Connection failed!\n", __FILE__, __LINE__);
		}
	}
	if(exception != NO_EXCEPTION) return exception;
	
	static StringDescr_T publishTopicDescription;
	static char *topic = "lintang";
	StringDescr_wrap(&publishTopicDescription, topic);
	
	mqttWasPublished = false;
	/* This is a dummy take. In case of any callback received
	 * after the previous timeout will be cleared here. */
	(void) xSemaphoreTake(mqttPublishHandle, 0UL);
	if (RC_OK != Mqtt_publish(&mqttSession, publishTopicDescription, *value, strlen(*value), (uint8_t) MQTT_QOS_AT_MOST_ONE, false))
	{
	    exception = RETCODE(RETCODE_SEVERITY_ERROR, RETCODE_MQTT_PUBLISH_FAILED);
	}
	
	if(exception != NO_EXCEPTION) return exception;
	
	if (pdTRUE != xSemaphoreTake(mqttPublishHandle, pdMS_TO_TICKS(5000)))
	{
		exception = RETCODE(RETCODE_SEVERITY_ERROR, RETCODE_MQTT_SUBSCRIBE_CB_NOT_RECEIVED);
	}
	else
	{
		if (true != mqttWasPublished)
		{
			exception = RETCODE(RETCODE_SEVERITY_ERROR, RETCODE_MQTT_SUBSCRIBE_STATUS_ERROR);
		}
	}
	
	return exception;
	
	return NO_EXCEPTION;
}


/**
 * @brief Callback function used by the stack to communicate events to the application.
 * Each event will bring with it specialized data that will contain more information.
 *
 * @param[in] session
 * MQTT session
 *
 * @param[in] event
 * MQTT event
 *
 * @param[in] eventData
 * MQTT data based on the event
 *
 */
static retcode_t MqttEventHandler(MqttSession_T* session, MqttEvent_t event, const MqttEventData_t* eventData)
{
	BCDS_UNUSED(session);
	BCDS_UNUSED(eventData);
	Retcode_T exception = RETCODE_OK;
	switch (event)
	{
	case MQTT_CONNECTION_ESTABLISHED:
		mqttIsConnected = true;
		if (pdTRUE != xSemaphoreGive(mqttConnectHandle))
		{
			exception = RETCODE(RETCODE_SEVERITY_ERROR, RETCODE_SEMAPHORE_ERROR);
		}
		break;
	case MQTT_CONNECTION_ERROR:
	case MQTT_CONNECT_SEND_FAILED:
	case MQTT_CONNECT_TIMEOUT:
		mqttIsConnected = false;
		if (pdTRUE != xSemaphoreGive(mqttConnectHandle))
		{
			exception = RETCODE(RETCODE_SEVERITY_ERROR, RETCODE_SEMAPHORE_ERROR);
		}

		break;
	case MQTT_CONNECTION_CLOSED:
		mqttIsConnected = false;
		printf("[WARNING, %s:%d] MQTT_Event : Disconnected. Will try to reconnect on next send.\n", __FILE__, __LINE__);
		break;
	case MQTT_SUBSCRIPTION_ACKNOWLEDGED:
		mqttIsSubscribed = true;
		if (pdTRUE != xSemaphoreGive(mqttSubscribeHandle))
		{
			exception = RETCODE(RETCODE_SEVERITY_ERROR, RETCODE_SEMAPHORE_ERROR);
		}
		break;
	case MQTT_SUBSCRIBE_SEND_FAILED:
	case MQTT_SUBSCRIBE_TIMEOUT:
		mqttIsSubscribed = false;
		if (pdTRUE != xSemaphoreGive(mqttSubscribeHandle))
		{
			exception = RETCODE(RETCODE_SEVERITY_ERROR, RETCODE_SEMAPHORE_ERROR);
		}
		break;
	case MQTT_SUBSCRIPTION_REMOVED:
		exception = RETCODE(RETCODE_SEVERITY_ERROR, RETCODE_MQTT_SUBSCRIBE_REMOVED);
		break;
	case MQTT_INCOMING_PUBLISH:
		break;
	case MQTT_PUBLISHED_DATA:
		mqttWasPublished = true;
		if (pdTRUE != xSemaphoreGive(mqttPublishHandle))
		{
			exception = RETCODE(RETCODE_SEVERITY_ERROR, RETCODE_SEMAPHORE_ERROR);
		}
		break;
	case MQTT_PUBLISH_SEND_FAILED:
	case MQTT_PUBLISH_SEND_ACK_FAILED:
	case MQTT_PUBLISH_TIMEOUT:
		mqttWasPublished = false;
		if (pdTRUE != xSemaphoreGive(mqttPublishHandle))
		{
			exception = RETCODE(RETCODE_SEVERITY_ERROR, RETCODE_SEMAPHORE_ERROR);
		}
		break;
	default:
		printf("[INFO, %s:%d] MqttEventHandler : Unhandled MQTT Event: %x\n", __FILE__, __LINE__, event);
		break;
	}

	if (RETCODE_OK != exception)
	{
		Retcode_RaiseError(exception);
	}

	return RC_OK;
}

/**
 * Connects to a configured backend.
 */
Retcode_T connectToBackend(void) {
	/* This is a dummy take. In case of any callback received
	 * after the previous timeout will be cleared here. */
	(void) xSemaphoreTake(mqttConnectHandle, 0UL);
	retcode_t rc = Mqtt_connect(&mqttSession);
	if(RC_OK != rc) {
		printf("[ERROR, %s:%d] MQTT_Connect : Failed to connect MQTT: 0x%d\n", __FILE__, __LINE__, rc);
		return RETCODE(RETCODE_SEVERITY_ERROR, RETCODE_MQTT_CONNECT_FAILED);
	}
	if (pdTRUE != xSemaphoreTake(mqttConnectHandle, pdMS_TO_TICKS(30000)))
	{
		printf("[ERROR, %s:%d] MQTT_Connect : Failed since Post CB was not received\n", __FILE__, __LINE__);
		return RETCODE(RETCODE_SEVERITY_ERROR, RETCODE_MQTT_CONNECT_CB_NOT_RECEIVED);
	}
	if (!mqttIsConnected)
	{
		printf("[ERROR, %s:%d] MQTT_Connect : Failed to connect\n", __FILE__, __LINE__);
		return RETCODE(RETCODE_SEVERITY_ERROR, RETCODE_MQTT_CONNECT_STATUS_ERROR);
	}
	return RETCODE_OK;
}

